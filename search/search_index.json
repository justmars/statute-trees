{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Statute Trees Docs","text":""},{"location":"#rules","title":"Rules","text":"<p>Rules are tree-based. This library facilitates the creation of codifications, statutes, and documents in the form of trees.</p> Python<pre><code>trees=CodeUnit(\nitem='Modern Child and Youth Welfare Code',\ncaption=None,\ncontent=None,\nid='1.',\nhistory=None,\nunits=[\nCodeUnit(\nitem='Title I',\ncaption='General Principles',\ncontent=None,\nid='1.1.',\nhistory=None,\nunits=[\nCodeUnit(\nitem='Article 1',\ncaption='Declaration of Policy.',\ncontent=None,\nid='1.1.1.',\nhistory=None,\nunits=[\nCodeUnit(\nitem='Paragraph 1',\ncaption=None,\ncontent='The Child is one of the most important assets of the nation. Every effort should be exerted to promote his welfare and enhance his opportunities for a useful and happy life.',\nid='1.1.1.1.',\nhistory=None,\nunits=[]\n),\nCodeUnit(\nitem='Paragraph 2',\ncaption=None,\ncontent='The child is not a mere creature of the State. Hence, his individual traits and aptitudes should be cultivated to the utmost insofar as they do not conflict with the general welfare.',\nid='1.1.1.2.',\nhistory=None,\nunits=[]\n),\n]\n)\n]\n)\n]\n... # sample excludes the rest of the tree\n)\n</code></pre>"},{"location":"#categories","title":"Categories","text":"<p>We'll concern ourselves with 3 distinct categorizations of trees as they apply to Philippine law:</p> <ol> <li>Codification Trees</li> <li>Statute Trees</li> <li>Document Trees</li> </ol> <p>Each of these trees rely on a similar <code>Node</code> structure consisting of the following fields:</p> Python<pre><code>class Node:\nitem: str\ncaption: str\ncontent: str\n</code></pre> <p>If we imagine this to be the root of the tree, it can branch out using a <code>units</code> key like so:</p> Python<pre><code>&gt;&gt;&gt; data = [\n{\n\"item\": \"Preliminary Title\",\n\"units\": [\n{\n\"item\": \"Chapter 1\",\n\"caption\": \"Effect and Application of Laws\",\n\"units\": [\n{\n\"item\": \"Article 1\",\n\"content\": 'This Act shall be known as the \"Civil Code of the Philippines.\" (n)\\n',\n},\n{\n\"item\": \"Article 2\",\n\"content\": \"Laws shall take effect after fifteen days following the completion of their publication either in the Official Gazette or in a newspaper of general circulation in the Philippines, unless it is otherwise provided. (1a)\\n\",\n},\n],\n}\n],\n}\n]\n</code></pre> <p>Since each branch needs to be validated, i.e. have the correct type of information per field. We utilize Pydantic for each of the main categories.</p>"},{"location":"#prerequisite","title":"Prerequisite","text":"<p>To add a new statute-pattern that will get recognized, update the <code>statute-patterns</code> library.</p> <p>This enables the <code>Rule</code> mechanism, a pre-requisite to utilizing the <code>StatuteBase</code> pydantic model.</p> <p>Trees are a crucial cog in the <code>corpus-x</code> library.</p>"},{"location":"trees/","title":"Trees","text":""},{"location":"trees/#unit","title":"Unit","text":"<p>         Bases: <code>BaseModel</code></p> <p>Generic node containing the <code>item</code>, <code>caption</code> and <code>content</code> fields.</p> Field Purpose Example <code>item</code> Provide a baseline position of the node Article 2 <code>caption</code> That position can have a descriptive caption Definition of Terms. <code>content</code> Host the text corresponding to the <code>item</code> You can think of a \"node\" as a branch or leaf of a tree. <p>Used in all tree-like structures to signify a node in the tree. Consider:</p> <pre><code>    flowchart\n        subgraph Article-2\n            direction LR\n            art-2-item[item: Article 2]\n            art-2-caption[caption: Definition of Terms...]\n        end\n        subgraph Article-1\n            direction LR\n            art-1-item[item: Article 1]\n            art-1-content[content: This Act shall be known...]\n        end</code></pre> Source code in <code>statute_trees/resources.py</code> Python<pre><code>class Node(BaseModel):\n\"\"\"Generic node containing the `item`, `caption` and `content` fields.\n    Field | Purpose | Example\n    :--:|:--:|:--\n    `item` | Provide a baseline position of the node | *Article 2*\n    `caption` | That position can have a descriptive caption | Definition of Terms.\n    `content` | Host the text corresponding to the `item` | You can think of a \"node\" as a branch or leaf of a tree.\n    Used in all tree-like structures to signify a node in the tree. Consider:\n    ```mermaid\n        flowchart\n            subgraph Article-2\n                direction LR\n                art-2-item[item: Article 2]\n                art-2-caption[caption: Definition of Terms...]\n            end\n            subgraph Article-1\n                direction LR\n                art-1-item[item: Article 1]\n                art-1-content[content: This Act shall be known...]\n            end\n    ```\n    \"\"\"  # noqa: E501\nitem: str = generic_item\ncaption: str | None = generic_caption\ncontent: str | None = generic_content\n# validators\n_sectionize_item = validator(\"item\", allow_reuse=True)(normalize_sec)\n_string_cap = validator(\"caption\", allow_reuse=True)(normalize_caption)\nclass Config:\nanystr_strip_whitespace = True\n</code></pre>"},{"location":"trees/#treeish-node","title":"Treeish Node","text":"<p>         Bases: <code>ABC</code></p> <p>The building block of the tree. Each category of tree is different since the way they're built is nuanced, e.g. a <code>Code Unit</code> needs a <code>history</code> field, and <code>Doc Unit</code> need a <code>sources</code> field. However both types share the same foundational structure.</p> <p>The chief characteristic of a <code>TreeishNode</code> is that it is susceptible of being nested, hence the need for a method to <code>create_branches()</code>.</p> <p>See example of branching:</p> <pre><code>    flowchart TB\n        subgraph Preliminary-Title\n            item-prelim[item: Preliminary Title]\n        end\n        subgraph Chapter-1\n            direction LR\n            item[item: Chapter 1]\n            caption[caption: Effect and Application of Laws]\n        end\n        subgraph Article-1\n            direction LR\n            art-1-item[item: Article 1]\n            art-1-content[content: This Act shall be known...]\n        end\n        subgraph Article-2\n            direction LR\n            art-2-item[item: Article 2]\n            art-2-content[content: Laws shall take effect after...]\n        end\n        Preliminary-Title ---ptch1[contains ch. 1]--&gt; Chapter-1\n        Chapter-1 ---ch1art1[contains art. 1]--&gt; Article-1\n        Chapter-1 ---ch1art2[contains art. 2]--&gt; Article-2</code></pre> Source code in <code>statute_trees/resources.py</code> Python<pre><code>class TreeishNode(ABC):\n\"\"\"The building block of the tree. Each category of tree is different\n    since the way they're built is nuanced, e.g. a [`Code Unit`][code-unit] needs a\n    `history` field, and [`Doc Unit`][doc-unit] need a `sources` field.\n    However both types share the same foundational structure.\n    The chief characteristic of a `TreeishNode` is that it is susceptible of being\n    nested, hence the need for a method to `create_branches()`.\n    See example of branching:\n    ```mermaid\n        flowchart TB\n            subgraph Preliminary-Title\n                item-prelim[item: Preliminary Title]\n            end\n            subgraph Chapter-1\n                direction LR\n                item[item: Chapter 1]\n                caption[caption: Effect and Application of Laws]\n            end\n            subgraph Article-1\n                direction LR\n                art-1-item[item: Article 1]\n                art-1-content[content: This Act shall be known...]\n            end\n            subgraph Article-2\n                direction LR\n                art-2-item[item: Article 2]\n                art-2-content[content: Laws shall take effect after...]\n            end\n            Preliminary-Title ---ptch1[contains ch. 1]--&gt; Chapter-1\n            Chapter-1 ---ch1art1[contains art. 1]--&gt; Article-1\n            Chapter-1 ---ch1art2[contains art. 2]--&gt; Article-2\n    ```\n    \"\"\"\n@classmethod\n@abstractmethod\ndef create_branches(cls, units: list[dict], parent_id: str = \"1.\"):\n\"\"\"Each material path tree begins will eventually start with a root\n        of `1.` so that each branch will be a material path (identified by\n        the `id`) to the root.\"\"\"\nraise NotImplementedError(\n\"Tree-based nodes must have a create_branches() function; note\"\n\" that each branching function for each tree category is\"\n\" different.\"\n)\n@classmethod\n@abstractmethod\ndef searchables(cls, pk: str, units: list) -&gt; Iterator[dict]:\n\"\"\"The `pk` indicated refers to the container, i.e. the foreign key\n        Codification / Statute / Document. So every dict generated\n        will have a unique material path with a `unit_text` that is\n        searchable and highlightable via sqlite's FTS.\"\"\"\nraise NotImplementedError(\n\"Tree-based nodes must generate sqlite-compatible fts unit_text\"\n\" columns that is searchable and whose snippet (see sqlite's\"\n\" snippet() function) can be highlighted.\"\n)\n</code></pre>"},{"location":"trees/#statute_trees.resources.TreeishNode-functions","title":"Functions","text":""},{"location":"trees/#statute_trees.resources.TreeishNode.create_branches","title":"<code>create_branches(units, parent_id='1.')</code>  <code>classmethod</code> <code>abstractmethod</code>","text":"<p>Each material path tree begins will eventually start with a root of <code>1.</code> so that each branch will be a material path (identified by the <code>id</code>) to the root.</p> Source code in <code>statute_trees/resources.py</code> Python<pre><code>@classmethod\n@abstractmethod\ndef create_branches(cls, units: list[dict], parent_id: str = \"1.\"):\n\"\"\"Each material path tree begins will eventually start with a root\n    of `1.` so that each branch will be a material path (identified by\n    the `id`) to the root.\"\"\"\nraise NotImplementedError(\n\"Tree-based nodes must have a create_branches() function; note\"\n\" that each branching function for each tree category is\"\n\" different.\"\n)\n</code></pre>"},{"location":"trees/#statute_trees.resources.TreeishNode.searchables","title":"<code>searchables(pk, units)</code>  <code>classmethod</code> <code>abstractmethod</code>","text":"<p>The <code>pk</code> indicated refers to the container, i.e. the foreign key Codification / Statute / Document. So every dict generated will have a unique material path with a <code>unit_text</code> that is searchable and highlightable via sqlite's FTS.</p> Source code in <code>statute_trees/resources.py</code> Python<pre><code>@classmethod\n@abstractmethod\ndef searchables(cls, pk: str, units: list) -&gt; Iterator[dict]:\n\"\"\"The `pk` indicated refers to the container, i.e. the foreign key\n    Codification / Statute / Document. So every dict generated\n    will have a unique material path with a `unit_text` that is\n    searchable and highlightable via sqlite's FTS.\"\"\"\nraise NotImplementedError(\n\"Tree-based nodes must generate sqlite-compatible fts unit_text\"\n\" columns that is searchable and whose snippet (see sqlite's\"\n\" snippet() function) can be highlighted.\"\n)\n</code></pre>"},{"location":"trees/#statute-unit","title":"Statute Unit","text":"<p>         Bases: <code>Node</code>, <code>TreeishNode</code></p> <p>A Statute, as used in this application, is broadly construed. It will refer to any Rule imagined by rule-makers (generally legislators) \"in the abstract\".</p> <p>The rule-makers imagine an event that is likely to happen and think of ways to deal with such an event.</p> <p>For our purposes, a Statute can include the Constitution itself, rules concerning pleading, practice, and procedure issued by the Philippine Supreme Court, or even the veto message by the President.</p> Source code in <code>statute_trees/nodes_statute.py</code> Python<pre><code>class StatuteUnit(Node, TreeishNode):\n\"\"\"\n    A Statute, as used in this application, is broadly construed. It will refer\n    to any Rule imagined by rule-makers (generally legislators) \"in the abstract\".\n    The rule-makers imagine an event that is likely to happen and think of ways\n    to deal with such an event.\n    For our purposes, a Statute can include the Constitution itself, rules concerning\n    pleading, practice, and procedure issued by the Philippine Supreme Court, or even\n    the veto message by the President.\n    \"\"\"\nid: str = generic_mp\nunits: list[\"StatuteUnit\"] | None = Field(None)\n@classmethod\ndef create_branches(\ncls,\nunits: list[dict],\nparent_id: str = \"1.\",\n) -&gt; Iterator[\"StatuteUnit\"]:\nfor counter, u in enumerate(units, start=1):\nchildren = []  # default unit being evaluated\nid = f\"{parent_id}{str(counter)}.\"\nif subunits := u.pop(\"units\", None):  # potential children\nchildren = list(cls.create_branches(subunits, id))  # recursive\nyield StatuteUnit(**u, id=id, units=children)\n@classmethod\ndef searchables(cls, pk: str, units: list[\"StatuteUnit\"]):\nfor u in units:\nif u.caption:\nif u.content:\nyield dict(\nmaterial_path=u.id,\nstatute_id=pk,\nunit_text=f\"{u.caption}. {u.content}\",\n)\nelse:\nyield dict(\nmaterial_path=u.id, statute_id=pk, unit_text=u.caption\n)\nelif u.content:\nyield dict(\nmaterial_path=u.id, statute_id=pk, unit_text=u.content\n)\nif u.units:\nyield from cls.searchables(pk, u.units)\n@classmethod\ndef granularize(\ncls, pk: str, nodes: list[\"StatuteUnit\"]\n) -&gt; Iterator[dict]:\n\"\"\"Recursive flattening of the tree structure so that each material path\n        (with its separate item, caption, and content) can become their own row.\n        \"\"\"\nfor i in nodes:\ndata = i.dict()\ndata[\"statute_id\"] = pk\ndata[\"material_path\"] = data.pop(\"id\")\nyield dict(**data)\nif i.units:\nyield from cls.granularize(pk, i.units)\n</code></pre>"},{"location":"trees/#statute_trees.nodes_statute.StatuteUnit-functions","title":"Functions","text":""},{"location":"trees/#statute_trees.nodes_statute.StatuteUnit.granularize","title":"<code>granularize(pk, nodes)</code>  <code>classmethod</code>","text":"<p>Recursive flattening of the tree structure so that each material path (with its separate item, caption, and content) can become their own row.</p> Source code in <code>statute_trees/nodes_statute.py</code> Python<pre><code>@classmethod\ndef granularize(\ncls, pk: str, nodes: list[\"StatuteUnit\"]\n) -&gt; Iterator[dict]:\n\"\"\"Recursive flattening of the tree structure so that each material path\n    (with its separate item, caption, and content) can become their own row.\n    \"\"\"\nfor i in nodes:\ndata = i.dict()\ndata[\"statute_id\"] = pk\ndata[\"material_path\"] = data.pop(\"id\")\nyield dict(**data)\nif i.units:\nyield from cls.granularize(pk, i.units)\n</code></pre>"},{"location":"trees/#code-unit","title":"Code Unit","text":"<p>         Bases: <code>Node</code>, <code>TreeishNode</code></p>"},{"location":"trees/#statute_trees.nodes_codification.CodeUnit--basis","title":"Basis","text":"<p>To understand a <code>CodeUnit</code>, we need to understand its containing object, i.e. a Codification. A Codification is a restatement of a Statute that is updated over time by related Decisions and other Statutes. It is a human-edited attempt to unify disconnected Decisions and Statutes into a single entity.</p>"},{"location":"trees/#statute_trees.nodes_codification.CodeUnit--history","title":"History","text":"<p>For instance, the <code>Family Code of the Philippines</code> is contained in Executive Order No. 209 (1987). However it has since been amended by various laws such as Republic Act No. 8533 (1998) and Republic Act No. 10572 (2013) among others. In light of the need to record a history, each Codification may contain a <code>history</code> field.</p> Source code in <code>statute_trees/nodes_codification.py</code> Python<pre><code>class CodeUnit(Node, TreeishNode):\n\"\"\"\n    ## Basis\n    To understand a `CodeUnit`, we need to understand its containing object, i.e.\n    a Codification. A Codification is a restatement of a Statute that is updated\n    over time by related Decisions and other Statutes. It is a human-edited attempt\n    to unify disconnected Decisions and Statutes into a single entity.\n    ## History\n    For instance, the `Family Code of the Philippines` is contained in\n    Executive Order No. 209 (1987). However it has since been amended by\n    various laws such as Republic Act No. 8533 (1998) and\n    Republic Act No. 10572 (2013) among others. In light of the need to record\n    a history, each Codification may\n    contain a `history` field.\n    \"\"\"\nid: str = generic_mp\nhistory: list[CitationAffector | StatuteAffector] | None = Field(\nNone,\ntitle=\"Unit History\",\ndescription=(\n\"Used in Codifications to show each statute or citation affecting\"\n\" the unit.\"\n),\n)\nunits: list[\"CodeUnit\"] | None = Field(None)\n@classmethod\ndef create_branches(\ncls, units: list[dict], parent_id: str = \"1.\"\n) -&gt; Iterator[\"CodeUnit\"]:\nfor counter, u in enumerate(units, start=1):\nchildren = []  # default unit being evaluated\nid = f\"{parent_id}{str(counter)}.\"\nhistory = u.pop(\"history\", None)\nif subunits := u.pop(\"units\", None):  # potential children\nchildren = list(cls.create_branches(subunits, id))  # recursive\nyield CodeUnit(\n**u,\nid=id,\nhistory=history,\nunits=children,\n)\n@classmethod\ndef searchables(cls, pk: str, units: list[\"CodeUnit\"]):\nfor u in units:\nif u.caption:\nif u.content:\nyield dict(\nmaterial_path=u.id,\ncodification_id=pk,\nunit_text=f\"{u.caption}. {u.content}\",\n)\nelse:\nyield dict(\nmaterial_path=u.id,\ncodification_id=pk,\nunit_text=u.caption,\n)\nelif u.content:\nyield dict(\nmaterial_path=u.id, codification_id=pk, unit_text=u.content\n)\nif u.units:\nyield from cls.searchables(pk, u.units)\n</code></pre>"},{"location":"trees/#doc-unit","title":"Doc Unit","text":"<p>         Bases: <code>Node</code>, <code>TreeishNode</code></p> <p>Non-table, interim unit for Document objects.</p> Source code in <code>statute_trees/nodes_document.py</code> Python<pre><code>class DocUnit(Node, TreeishNode):\n\"\"\"Non-table, interim unit for Document objects.\"\"\"\nid: str = generic_mp\nsources: list[EventStatute | EventCitation | FTSQuery] | None = Field(\nNone,\ntitle=\"Legal Basis Sources\",\ndescription=\"Used in Documents to show the basis of the content node.\",\n)\nunits: list[\"DocUnit\"] = Field(None)\n@classmethod\ndef create_branches(\ncls, units: list[dict], parent_id: str = \"1.\"\n) -&gt; Iterator[\"DocUnit\"]:\nif parent_id == \"1.\":\nLayers.DEFAULT.layerize(units)  # in place\nfor counter, u in enumerate(units, start=1):\nchildren = []  # default unit being evaluated\nid = f\"{parent_id}{str(counter)}.\"\nsources = u.pop(\"sources\", None)\nif subunits := u.pop(\"units\", None):  # potential children\nchildren = list(cls.create_branches(subunits, id))  # recursive\nyield DocUnit(**u, id=id, sources=sources, units=children)\n@classmethod\ndef searchables(cls, pk: str, units: list[\"DocUnit\"]):\nfor u in units:\nif u.caption:\nif u.content:\nyield dict(\nmaterial_path=u.id,\ndocument_id=pk,\nunit_text=f\"{u.caption}. {u.content}\",\n)\nelse:\nyield dict(\nmaterial_path=u.id,\ndocument_id=pk,\nunit_text=u.caption,\n)\nelif u.content:\nyield dict(\nmaterial_path=u.id,\ndocument_id=pk,\nunit_text=u.content,\n)\nif u.units:\nyield from cls.searchables(pk, u.units)\n</code></pre>"},{"location":"utils/","title":"Example Data","text":"<p>Some functions to help with tree like (json-ish) python structures.</p>"},{"location":"utils/#setter-of-ids","title":"Setter of IDs","text":"Python<pre><code>&gt;&gt;&gt; from statute_trees.utils import set_node_ids\n&gt;&gt;&gt; set_node_ids(data)\n# all nodes in the tree will now have an `id` key, e.g.:\n{\n\"item\": \"Article 1\",\n\"content\": 'This Act shall be known as the \"Civil Code of the Philippines.\" (n)\\n',\n\"id\": \"1.1.1.1.\"\n}\n</code></pre>"},{"location":"utils/#getter-of-node-by-id","title":"Getter of Node by ID","text":"Python<pre><code>&gt;&gt;&gt; from statute_trees.utils import get_node_id\n&gt;&gt;&gt; get_node_id(\"1.1.1.1.\")\n{\n\"item\": \"Article 1\",\n\"content\": 'This Act shall be known as the \"Civil Code of the Philippines.\" (n)\\n',\n\"id\": \"1.1.1.1.\"\n}\n</code></pre>"},{"location":"utils/#enables-limited-enumeration-per-layer","title":"Enables Limited Enumeration Per Layer","text":"Python<pre><code>&gt;&gt;&gt; raw = [\n{\"content\": \"Parent Node 1\"},\n{\n\"content\": \"Parent Node 2\",\n\"units\": [\n{\n\"content\": \"Hello World!\",\n\"units\": [\n{\"content\": \"Deeply nested content\"},\n{\"content\": \"Another deeply nested one\"},\n],\n},\n{\"content\": \"Another Hello World!\"},\n],\n},\n]\n&gt;&gt;&gt; from statute_trees.utils import Layers\n&gt;&gt;&gt; Layers.DEFAULT(raw) # note the addition of the `item` key to the raw itemless data\n[{'content': 'Parent Node 1', 'item': 'I'},\n{'content': 'Parent Node 2',\n'units': [{'content': 'Hello World!',\n'units': [{'content': 'Deeply nested content', 'item': 1},\n{'content': 'Another deeply nested one', 'item': 2}],\n'item': 'A'},\n{'content': 'Another Hello World!', 'item': 'B'}],\n'item': 'II'}]\n</code></pre>"},{"location":"utils/#fetcher-of-values","title":"Fetcher of Values","text":"Python<pre><code>&gt;&gt;&gt; from statute_trees.utils import test_fetch_values_from_key\n&gt;&gt;&gt; list(test_fetch_values_from_key(data[0]), \"item\")\n[\n\"Preliminary Title\",\n\"Chapter 1\",\n\"Article 2\",\n\"Article 1\",\n]\n</code></pre>"}]}